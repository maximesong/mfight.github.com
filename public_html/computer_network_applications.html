<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Network Applications:Overview, Email, Ftp</title>
    <meta name="generator" content="muse.el" />
    <meta http-equiv="Content-Type"
          content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="style.css" /> <script type="text/javascript"> var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-25182468-1']);_gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(ga, s);})();</script><script type="text/javascript"src="scripts/shCore.js"></script><script type="text/javascript"src="scripts/shBrushCpp.js"></script><link href="styles/shCore.css" rel="stylesheettype="text/css" /><link href="styles/shThemeEmacs.css" rel="stylesheet"type="text/css" />
  </head>
  <body>
    <h1>Network Applications:Overview, Email, Ftp</h1>
<!-- menu start here -->
     <div class="menu">
        <div class="menuitem">
          <a href=" ../index.html">Home</a>
        </div>

        <div class="menuitem">
          <a href=" index.html">Computer</a>
        </div>
       </div>
     <div class="menub">       
	<div class="menuitemb">
          <a href=" francais.html">Fran√ßais</a>
        </div>

        <div class="menuitemb">
          <a href=" word_list.html">Wordlist</a>
        </div>
      </div>
    <!-- menu ends here -->
    <!-- Page published by Emacs Muse begins here -->
<div class="mulu">
<h6 class="mulu">Contents</h6>
<dl class="contents">
<dt class="contents">
<a href="#sec1">Secure Socket Layer: Services</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec2">Publ./latex/latex2png-computer_network_applications__305825782.pngithmsn</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec3">Properties</a>
</dt>
<dt class="contents">
<a href="#sec4">Examples</a>
</dt>
<dt class="contents">
<a href="#sec5">Certification Authorities</a>
</dt>
</dl>
</dd>
</dl>
</dd>
<dt class="contents">
<a href="#sec6">Application layer overview</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec7">Killer Applications</a>
</dt>
<dt class="contents">
<a href="#sec8">Conceptual + implementation aspects of network application protocols</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec9">Client server paradigm</a>
</dt>
<dt class="contents">
<a href="#sec10">Peer to peer paradigm</a>
</dt>
</dl>
</dd>
<dt class="contents">
<a href="#sec11">Common application-layer protocols</a>
</dt>
<dt class="contents">
<a href="#sec12">What Transport Service Does an App Need?</a>
</dt>
</dl>
</dd>
<dt class="contents">
<a href="#sec13">Examples</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec14">Electronic Mail</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec15">Three major components</a>
</dt>
<dt class="contents">
<a href="#sec16">workflow</a>
</dt>
<dt class="contents">
<a href="#sec17">Mail Message Format</a>
</dt>
<dt class="contents">
<a href="#sec18">POP3 Protocol: Mail Access</a>
</dt>
<dt class="contents">
<a href="#sec19">Positive</a>
</dt>
<dt class="contents">
<a href="#sec20">Negative</a>
</dt>
</dl>
</dd>
<dt class="contents">
<a href="#sec21">FTP: the File Transfer Protocol</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec22">Sample commands</a>
</dt>
<dt class="contents">
<a href="#sec23">Sample return codes</a>
</dt>
<dt class="contents">
<a href="#sec24">Active Mode</a>
</dt>
<dt class="contents">
<a href="#sec25">Passive Mode</a>
</dt>
</dl>
</dd>
<dt class="contents">
<a href="#sec26">HTTP: hypertex transfer protocol</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec27">Message flow</a>
</dt>
<dt class="contents">
<a href="#sec28">HTTP Request Message: General Format</a>
</dt>
<dt class="contents">
<a href="#sec29">Http Response Message</a>
</dt>
<dt class="contents">
<a href="#sec30">HTTP/1.0 Delay</a>
</dt>
<dt class="contents">
<a href="#sec31">Persistent HTTP</a>
</dt>
<dt class="contents">
<a href="#sec32">Browser Cache and Conditional GET</a>
</dt>
<dt class="contents">
<a href="#sec33">Keeping State: Cookies</a>
</dt>
<dt class="contents">
<a href="#sec34">Authentication(401: authorization req.)</a>
</dt>
</dl>
</dd>
<dt class="contents">
<a href="#sec35">DNS: Domain Name System(port 53)</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec36">Translate Machine Names to IPs</a>
</dt>
<dt class="contents">
<a href="#sec37">How it works</a>
</dt>
<dt class="contents">
<a href="#sec38">Types of Queries</a>
</dt>
<dt class="contents">
<a href="#sec39">DNS Records</a>
</dt>
<dt class="contents">
<a href="#sec40">DNS Protocol, Messages</a>
</dt>
<dt class="contents">
<a href="#sec41">Observing DNS</a>
</dt>
<dt class="contents">
<a href="#sec42">What DNS did Right?</a>
</dt>
<dt class="contents">
<a href="#sec43">Problems of DNS</a>
</dt>
</dl>
</dd>
<dt class="contents">
<a href="#sec44">P2P</a>
</dt>
<dd>
<dl class="contents">
<dt class="contents">
<a href="#sec45">Summary of Traditional C-S Network Applications</a>
</dt>
<dt class="contents">
<a href="#sec46">Objectives of P2P</a>
</dt>
<dt class="contents">
<a href="#sec47">What is P2P</a>
</dt>
<dt class="contents">
<a href="#sec48">History and Now</a>
</dt>
<dt class="contents">
<a href="#sec49">Centralized Database: Napster</a>
</dt>
<dt class="contents">
<a href="#sec50">Decentralized Flooding: Gnutella</a>
</dt>
<dt class="contents">
<a href="#sec51">Freenet</a>
</dt>
<dt class="contents">
<a href="#sec52">Unstructed P2P Summary</a>
</dt>
<dt class="contents">
<a href="#sec53">Distributed Hash Tables(DHT)</a>
</dt>
<dt class="contents">
<a href="#sec54">Chord</a>
</dt>
<dt class="contents">
<a href="#sec55">Content Addressable Network(CAN)</a>
</dt>
<dt class="contents">
<a href="#sec56">Chord/CAN Summary</a>
</dt>
<dt class="contents">
<a href="#sec57">Tapestry (Zhao et al)</a>
</dt>
<dt class="contents">
<a href="#sec58">Skip List</a>
</dt>
<dt class="contents">
<a href="#sec59">Summary: DHT</a>
</dt>
<dt class="contents">
<a href="#sec60">Summary: the lookup problem</a>
</dt>
<dt class="contents">
<a href="#sec61">BitTorrent</a>
</dt>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>

<h2><a name="sec1" id="sec1"></a>Secure Socket Layer: Services</h2>

<ul>
<li>Server authentication

<ul>
<li>Authentication through trusted certificate authority(CA):server obtains a certificate from one of the trusted CAs</li>
</ul></li>
<li>Data encryption and integrity</li>
<li>Client authentication(optional)</li>
</ul>

<h3><a name="sec2" id="sec2"></a>Public-Key Algorithmsn</h3>

<ul>
<li>Both public key and private key can be used to encode and decode</li>
<li>One can generate public key from private key, but not in the other direction.
<h4><a name="sec3" id="sec3"></a>Properties</h4></li>

<li>D(E(P)) = P</li>
<li>It is exceedingly difficult to deduce D from E</li>
<li>E cannot be broken by a chosen plaintext attack</li>
</ul>


<h4><a name="sec4" id="sec4"></a>Examples</h4>

<ul>
<li>Knapsack</li>
<li>RSA</li>
<li>Elliptic curves</li>
</ul>


<h4><a name="sec5" id="sec5"></a>Certification Authorities</h4>

<ul>
<li>Certification authority(CA): binds public key to particular entity, E</li>
<li>E(person, router) registers its public key with CA.

<ul>
<li>E provides &quot;proof of identity&quot; to CA</li>
<li>CA creates certificate binding E to its public key.</li>
<li>Certificate contains E's public key digitally signed by CA &mdash; CA says &quot;this is E's public key&quot;</li>
</ul></li>
<li>When Alice wants Bob's public key

<ul>
<li>Gets Bob's certificate</li>
<li>Apply CA's public key to Bob's certificate, get Bob's public key.</li>
</ul></li>
</ul>

<h5>A Certificate Contains</h5>

<ul>
<li>Serial number(unique to issuer)</li>
<li>Info about certificate owner, including algorithm and key value itself</li>
<li>Info about certificate issuer</li>
<li>valid dates

<ul>
<li>digital signature by issuer</li>
</ul></li>
</ul>

<p class="image"><img src="ssl_architecture.png" alt="" /></p>

<p class="image"><img src="ssl_format.png" alt="" /></p>





<h2><a name="sec6" id="sec6"></a>Application layer overview</h2>

<h3><a name="sec7" id="sec7"></a>Killer Applications</h3>

<ul>
<li>70s and 80s

<ul>
<li>Text email, remote access, file transfers, newsgroups, text chat</li>
</ul></li>
<li>90s

<ul>
<li>WWW - surfing, search, e-commenrce</li>
<li>At the end of millennium -IM, P2P file sharing</li>
</ul></li>
<li>New century</li>
<li>Multimedia(YouTube, Flickr, Youku)</li>
<li>Social networking(Facebook, Twitter, Weibo)</li>
</ul>



<h3><a name="sec8" id="sec8"></a>Conceptual + implementation aspects of network application protocols</h3>

<h4><a name="sec9" id="sec9"></a>Client server paradigm</h4>

<h5>Client</h5>

<ul>
<li>Initiates contact with server(&quot;speaks first&quot;)</li>
<li>Typically reuests service from server</li>
<li>For Web, client is implemented in browser; for email, in mail reader</li>
</ul>


<h5>Server</h5>

<ul>
<li>Provides reuested service to client, e.g. Web server sends requested Web page; mail server delivers e-mail.</li>
</ul>


<h5>Two questions to ask about a C-S application</h5>

<p>- How does a client locate a server process?
- Is the application scalable, extensible,robust?</p>



<h4><a name="sec10" id="sec10"></a>Peer to peer paradigm</h4>



<h3><a name="sec11" id="sec11"></a>Common application-layer protocols</h3>

<ul>
<li>SMTP/POP</li>
<li>HTTP</li>
<li>FTP</li>
<li>DNS</li>
<li>P2P</li>
</ul>


<h3><a name="sec12" id="sec12"></a>What Transport Service Does an App Need?</h3>

<ul>
<li>Data loss

<ul>
<li>Some apps can to tolerate some packet losses</li>
<li>Other apps require 100% reliable data transfer</li>
</ul></li>
<li>Bandwidth

<ul>
<li>Some apps require minimum amount of bandwidth to be &quot;effective&quot;</li>
<li>Other apps make use of whatever bandwidth they get</li>
</ul></li>
<li>Timing

<ul>
<li>Some apps require low delay to be &quot;effective&quot;</li>
</ul></li>
</ul>

<p class="image"><img src="applications_transport_protocal.png" alt="" /></p>


<p class="image"><img src="applications_transport_requirements.png" alt="" /></p>



<h2><a name="sec13" id="sec13"></a>Examples</h2>

<h3><a name="sec14" id="sec14"></a>Electronic Mail</h3>

<h4><a name="sec15" id="sec15"></a>Three major components</h4>

<ul>
<li>User agents</li>
<li>Mail servers</li>
<li>Protocols

<ul>
<li>Between mail servers: STMP</li>
<li>Between mail server and user agent

<ul>
<li>POP3:Post Office Protocol</li>
<li>IMAP:Internet Mail Access Protocol</li>
</ul></li>
</ul></li>
</ul>


<h4><a name="sec16" id="sec16"></a>workflow</h4>

<ul>
<li>HELO</li>
<li>MAIL FROM</li>
<li>RCPT TO</li>
<li>DATA</li>
<li>QUIT</li>
</ul>


<h4><a name="sec17" id="sec17"></a>Mail Message Format</h4>

<p class="first">SMTP: protocol for exchanging email msgs</p>

<p>RFC 822: standard for text message format</p>

<ul>
<li>Header line

<ul>
<li>To:</li>
<li>From:</li>
<li>Subject:</li>
</ul></li>
<li>Body

<ul>
<li>the &quot;message&quot;, ASCII characters only</li>
</ul></li>
</ul>

<p>MIME: multimedia mail extention, RFC 2045, 2056</p>

<ul>
<li>Addictional lines in smg header declare MIMI content type</li>
</ul>


<h4><a name="sec18" id="sec18"></a>POP3 Protocol: Mail Access</h4>

<h5>Authorization phase</h5>

<ul>
<li>Client commands:

<ul>
<li>user: declare username</li>
<li>pass: password</li>
</ul></li>
<li>Server responses

<ul>
<li>+OK</li>
<li>-ERR</li>
</ul></li>
</ul>


<h5>Transaction phase</h5>

<ul>
<li>list: list message numbers</li>
<li>retr: retrive message by number</li>
<li>dele: delete</li>
<li>quit</li>
</ul>



<h4><a name="sec19" id="sec19"></a>Positive</h4>

<ul>
<li>Separate protocols for different functions

<ul>
<li>Email retrieval(e.g. POP3, IMAP)</li>
<li>Mail transmission(SMTP)</li>
</ul></li>
<li>Simple/basic request to implement basic control; fine-grain control through ASCII header and message body

<ul>
<li>Make the protocol easy to read/debug/extend(analogy with end-to-end layered design)</li>
<li>Status code in response makes message easy to parse</li>
</ul></li>
</ul>


<h4><a name="sec20" id="sec20"></a>Negative</h4>

<ul>
<li>Some design features which are missing

<ul>
<li>Handling spam</li>
</ul></li>
</ul>



<h3><a name="sec21" id="sec21"></a>FTP: the File Transfer Protocol</h3>

<p class="first">Transfer files to/from remote host
FTP: RFC 959, server port 21(smtp 25, http 80)</p>

<ul>
<li>Two Parallel TCP connections opened

<ul>
<li>Control: exchange commands, responses between client, server

<ul>
<li>out of band control</li>
<li>port 21 at server</li>
</ul></li>
<li>Data: file data to/from server

<ul>
<li>port 20 at server</li>
</ul></li>
</ul></li>
<li>FTP server maintains &quot;state&quot;, e.g.

<ul>
<li>Current directory</li>
<li>Earlier authentication</li>
</ul></li>
</ul>

<h4><a name="sec22" id="sec22"></a>Sample commands</h4>

<ul>
<li>sent as ASCII text over control</li>
<li>USER: username</li>
<li>PASS: password</li>
<li>PORT h1,h2,h3,h4,p1,p2: specifies the IP address and port the client receives its data</li>
<li>LIST: return list of file in current</li>
<li>RETR filename: retrieves(get) file</li>
<li>STOR filename: stores file</li>
</ul>


<h4><a name="sec23" id="sec23"></a>Sample return codes</h4>

<ul>
<li>331 Username OK, password required</li>
<li>125 data connection already open; transfer</li>
<li>425 Can‚Äôt open data connection</li>
<li>452 Error writing file</li>
</ul>


<h4><a name="sec24" id="sec24"></a>Active Mode</h4>

<ul>
<li>Server initiates data connection to the client's port</li>
</ul>

<p class="image"><img src="ftp_active_mode.png" alt="" /></p>


<h4><a name="sec25" id="sec25"></a>Passive Mode</h4>

<ul>
<li>Server acks with a port number</li>
<li>Client connects to server's data port</li>
</ul>

<p class="image"><img src="ftp_passive_mode.png" alt="" /></p>



<h3><a name="sec26" id="sec26"></a>HTTP: hypertex transfer protocol</h3>

<p class="first">Web's application layer protocol</p>

<ul>
<li>HTTP uses TCP as transport service</li>
<li>Client/server model

<ul>
<li>Client: browser that requests, receives, &quot;display&quot; Web objects</li>
<li>Server: Web server sends objects in response to requests</li>
</ul></li>
<li>Http 1.0: RFC 1945, HTTP 1.1: RFC 2068</li>
</ul>

<h4><a name="sec27" id="sec27"></a>Message flow</h4>

<ul>
<li>Web server waiting for TCP connection at port 80(default)</li>
<li>Client initiates TCP connection(creates socket) to server, port 80</li>
<li>Server &quot;accepts&quot; connection, ack client and waits for request from clients</li>
<li>Client sends request message(containing URL) into TCP connection socket for a document</li>
<li>Web server receives request message, forms response message containing the document, and sends message into socket(slow-start).</li>
<li>Web server closes TCP connection closed</li>
<li>Client parses the document to find embedded objects(images)

<ul>
<li>Repeat above for each image</li>
</ul></li>
</ul>


<h4><a name="sec28" id="sec28"></a>HTTP Request Message: General Format</h4>

<p class="image"><img src="http_request_format.png" alt="" /></p>

<p class="image"><img src="http_request_message.png" alt="" /></p>


<h4><a name="sec29" id="sec29"></a>Http Response Message</h4>

<p class="image"><img src="http_response_message.png" alt="" /></p>

<h5>Status Codes</h5>

<p>In the first line of the response message.</p>

<ul>
<li>200 OK

<ul>
<li>request succeeded, requested object later in this message</li>
</ul></li>
<li>301 Moved Permanently

<ul>
<li>requested object moved, new location specified later in this message(Location:)</li>
</ul></li>
<li>400 Bad Request

<ul>
<li>request message not understood by server</li>
</ul></li>
<li>404 Not Found

<ul>
<li>requested document not found on this server</li>
</ul></li>
<li>505 HTTP Version Not Supported</li>
</ul>



<h4><a name="sec30" id="sec30"></a>HTTP/1.0 Delay</h4>

<ul>
<li>For each object

<ul>
<li>TCP handshake &mdash; 1 RTT</li>
<li>Client request and server responds &mdash; at least 1 RTT</li>
</ul></li>
</ul>


<h4><a name="sec31" id="sec31"></a>Persistent HTTP</h4>

<ul>
<li>Default to HTTP/1.1</li>
<li>On same TCP connection: server parse request, responds, parse new request, ...</li>
<li>Client sends requests for all referenced objects as soon as it receives base HTML</li>
<li>Fewer RTTs</li>
</ul>


<h4><a name="sec32" id="sec32"></a>Browser Cache and Conditional GET</h4>

<p class="first">Goals: don't send object if client has up-to-date stored(cached) version</p>

<ul>
<li>client: specify date of cached copy in http request

<ul>
<li>If-modified-since:&lt;date&gt;</li>
</ul></li>
<li>server: response contains no object if cached copy up-to-date

<ul>
<li>HTTP/1.0 304 Not Modified</li>
</ul></li>
</ul>


<h4><a name="sec33" id="sec33"></a>Keeping State: Cookies</h4>

<p class="first">Goal: no explicit application level session</p>

<ul>
<li>Server sends &quot;cookie&quot; to client in response msg

<ul>
<li>Set-cookie: 1678353</li>
</ul></li>
<li>Client presents cookie in later requests

<ul>
<li>Cookie: 1678453</li>
</ul></li>
<li>Server matches presented-cookie with server-stored info

<ul>
<li>Authentication</li>
<li>Remebering user preferences, previous choices</li>
</ul></li>
</ul>


<h4><a name="sec34" id="sec34"></a>Authentication(401: authorization req.)</h4>

<p class="first">Goal: control access to server documents</p>

<ul>
<li>Stateless:client must present authorization in each request</li>
<li>Authorization: typically name, password

<ul>
<li>Authorization: header line in request</li>
<li>If no authorization presented, server refuses access, sends WWW-authenticate: header line in response</li>
</ul></li>
<li>Browser caches name &amp; password so that user does not have to repeatedly enter it.</li>
</ul>




<h3><a name="sec35" id="sec35"></a>DNS: Domain Name System(port 53)</h3>

<ul>
<li>gethostbyname()</li>
</ul>

<h4><a name="sec36" id="sec36"></a>Translate Machine Names to IPs</h4>

<ul>
<li>etc/hosts

<ul>
<li>OK for small networks</li>
<li>Not scalable, up-to-date</li>
<li>Conflicts</li>
</ul></li>
<li>DNS

<ul>
<li>Solve the above problems</li>
</ul></li>
</ul>


<h4><a name="sec37" id="sec37"></a>How it works</h4>

<ul>
<li>A distributed database managed by authoritative name servers

<ul>
<li>Each zone has its own authoritative name servers</li>
<li>An authoritative name server of a zone may delegate a subset (i.e. a sub-tree) of its zone to another name server</li>
</ul></li>
<li>The root zone is managed by the root name servers

<ul>
<li>13 root name servers worldwide</li>
</ul></li>
<li>Each name server knows the address of the root servers</li>
<li>Each name server knows the address of its immediate children</li>
</ul>


<h4><a name="sec38" id="sec38"></a>Types of Queries</h4>

<ul>
<li>Recursive query

<ul>
<li>Put burden of name resolution on contacted names server, the contacted name server resolves the name completely</li>
</ul></li>
<li>Iterated query

<ul>
<li>Contacted server relies with name of server to contact</li>
</ul></li>
<li>The hybrid case</li>
</ul>


<h4><a name="sec39" id="sec39"></a>DNS Records</h4>

<p class="first">DNS distributed db storing resource recors(RR)</p>

<ul>
<li>RR format: (name, type, value, ttl)</li>
<li>Type = A

<ul>
<li>name is hostname</li>
<li>value is IP address</li>
</ul></li>
<li>Type = NS

<ul>
<li>name is domain(e.g. yale.edu)</li>
<li>value is the name of the authoritative name server for this domain</li>
</ul></li>
<li>Type = CNAME

<ul>
<li>name is an alias name for some &quot;canonical&quot;(the real) name</li>
<li>value is canonical name</li>
</ul></li>
<li>Type = MX

<ul>
<li>value is hostname of mail server associated with name</li>
</ul></li>
<li>Type = SRV

<ul>
<li>general extension</li>
</ul></li>
</ul>


<h4><a name="sec40" id="sec40"></a>DNS Protocol, Messages</h4>

<p class="first">Over UDP/TCP; query and reply messages,both with the same message format.</p>

<p class="image"><img src="dns_message_format.png" alt="" /></p>

<ul>
<li>identification: 16 bit # for query, the reply to a query uses the same #</li>
<li>flags:</li>
<li>Query or reply</li>
<li>Recursion desired</li>
<li>Recursion available</li>
<li>Reply is authoritative</li>
</ul>


<h4><a name="sec41" id="sec41"></a>Observing DNS</h4>

<p class="first">dig +trace www.cnn.com</p>


<h4><a name="sec42" id="sec42"></a>What DNS did Right?</h4>

<ul>
<li>Hierachical delegation avoids central control, improve manageability and scalability</li>
<li>Redundant servers improve robustness</li>
<li>Caching reduces workload and improve robustness</li>
</ul>


<h4><a name="sec43" id="sec43"></a>Problems of DNS</h4>

<ul>
<li>Domain names may not be the best way to name other resources, e.g. files</li>
<li>Relatively static resource types make it hard to introduce new services or handle mobility</li>
<li>Although theoretically you can update the values of the records, it is rarely enabled</li>
<li>Simple query model make it hard to implement advanced query</li>
<li>Early binding (separation of DNS query from application query) does not work well in mobile, dynamic environments</li>
<li>e.g. load balancing, locate the nearest printer</li>
</ul>



<h3><a name="sec44" id="sec44"></a>P2P</h3>

<h4><a name="sec45" id="sec45"></a>Summary of Traditional C-S Network Applications</h4>

<ul>
<li>down speed to the clients

<ul>
<li>slashdot effect</li>
<li>CNN on 9/11</li>
</ul></li>
</ul>


<h4><a name="sec46" id="sec46"></a>Objectives of P2P</h4>

<ul>
<li>Bypass DNS to access resources!

<ul>
<li>Examples: instant messaging, skype</li>
</ul></li>
<li>Share the storage and bandwidth of individual clients to improve scalability

<ul>
<li>Examples: file sharing and streaming</li>
</ul></li>
</ul>


<h4><a name="sec47" id="sec47"></a>What is P2P</h4>

<p class="first">P2P is simply an iteration of scalable distributed systems</p>


<h4><a name="sec48" id="sec48"></a>History and Now</h4>

<ul>
<li>Original Internet was a P2P system:

<ul>
<li>The original ARPANET connected UCLA, Stanford</li>
<li>Research Institute, UCSB, and Univ. of Utah</li>
<li>No DNS or routing infrastructure, just connected by phone lines</li>
<li>Computers also served as routers</li>
</ul></li>

<li>Quickly grown in popularity:

<ul>
<li>50-80% Internet traffic is P2P</li>
</ul></li>
</ul>


<h4><a name="sec49" id="sec49"></a>Centralized Database: Napster</h4>

<ul>
<li>Application-level, client-server protocol over TCP</li>
<li>A centralized index system that maps files (songs) to machines that are alive and with files</li>
</ul>

<h5>Steps:</h5>

<ul>
<li>Connect to Napster server</li>
<li>Upload your list of files (push) to server</li>
<li>Give server keywords to search the full list</li>
<li>Select ‚Äúbest‚Äù of hosts with answers</li>
</ul>


<h5>Summary of features: a hybrid design</h5>

<ul>
<li>Control: client-server (aka special DNS) for files</li>
<li>Data: peer to peer</li>
</ul>


<h5>Advantages</h5>

<ul>
<li>Simplicity, easy to implement sophisticated search engines on top of the index system</li>
</ul>


<h5>Disadvantages</h5>

<ul>
<li>Application specific (compared with DNS)</li>
<li>Lack of robustness, scalability: central search server single point of bottleneck/failure</li>
<li>Easy to sue !</li>
</ul>


<h5>Variation: BitTorrent</h5>

<ul>
<li>A global central index server is replaced by one tracker per file (called a swarm)

<ul>
<li>Reduces centralization; but needs other means to locate trackers</li>
</ul></li>
<li>The bandwidth scalability management technique is more interesting</li>
</ul>



<h4><a name="sec50" id="sec50"></a>Decentralized Flooding: Gnutella</h4>

<ul>
<li>On startup, client contacts other servents (server + client) in network to form interconnection/peering relationships

<ul>
<li>Servent interconnection used to forward control (queries, hits, etc)</li>
</ul></li>
</ul>

<h5>How to find a resource record: decentralized flooding</h5>

<ul>
<li>Send requests to neighbors</li>
<li>Neighbors recursively forward the requests</li>
<li>Each node forwards the query to its neighbors other than the one who forwards it the query</li>
<li>Each node should keep track of forwarded queries to avoid loop !

<ul>
<li>Nodes keep state (which will time out&mdash;soft state)</li>
<li>Carry the state in the query, i.e. carry a list of visited nodes</li>
</ul></li>
</ul>


<h5>Messages</h5>

<ul>
<li>Basic message header

<ul>
<li>Unique ID, TTL, Hops</li>
</ul></li>
<li>Message types

<ul>
<li>Ping ‚Äì probes network for other servents</li>
<li>Pong ‚Äì response to ping, contains IP addr, # of files, etc.</li>
<li>Query ‚Äì search criteria + speed requirement of servent</li>
<li>QueryHit ‚Äì successful response to Query, contains addr + port to transfer from, speed of servent, etc.</li>
</ul></li>
<li>Ping, Queries are flooded</li>
<li>QueryHit, Pong: reverse path of previous message</li>
</ul>


<h5>Advantages:</h5>

<ul>
<li>Totally decentralized, highly robust</li>
</ul>


<h5>Disadvantages</h5>

<ul>
<li>Not scalable; the entire network can be swamped with flood
requests</li>
<li>Especially hard on slow clients; at some point broadcast traffic on Gnutella exceeded 56 kbps</li>
<li>To alleviate this problem, each request has a TTL to limit the
scope</li>
<li>Each query has an initial TTL, and each node forwarding it reduces it by one; if TTL reaches 0, the query is dropped (consequence?)</li>
</ul>


<h5>Aside</h5>

<ul>
<li>Search Time</li>
<li>All Peers Equal(bandwidth)?</li>
<li>Network Resilience(what if some servents die)</li>
</ul>



<h5>Flooding: FastTrack (aka Kazaa)</h5>

<p>Modifies the Gnutella protocol into two-level hierarchy</p>

<ul>
<li>Supernodes

<ul>
<li>Nodes that have better connection to Internet</li>
<li>Act as temporary indexing servers for other nodes</li>
<li>Help improve the stability of the network</li>
</ul></li>
<li>Standard nodes

<ul>
<li>Connect to supernodes and report list of files
<h5>Search</h5></li>

<li>Broadcast (Gnutella-style) search across supernodes</li>
</ul></li>
</ul>



<h5>Disadvantages</h5>

<ul>
<li>Kept a centralized registration -&gt;ÔÉ† prone to law suits</li>
</ul>




<h4><a name="sec51" id="sec51"></a>Freenet</h4>

<ul>
<li>Goals:

<ul>
<li>Totally distributed system without using centralized index or broadcast (flooding)</li>
<li>Respond adaptively to usage patterns, transparently moving, replicating files as necessary to provide efficient service</li>
<li>Provide publisher anonymity, security</li>
<li>Free speech : resistant to attacks ‚Äì a third party shouldn‚Äòt be able to deny (e.g., deleting) the access to a particular file (data item, object)</li>
</ul></li>
</ul>

<h5>Basic Structure</h5>

<p>(id, next_hop, file)</p>

<ul>
<li>Each machine stores a set of files; each file is identified by a unique identifier (called key or id)</li>
<li>Each node maintains a ‚Äúrouting table&quot;

<ul>
<li>id ‚Äì file id, key</li>
<li>next_hop node ‚Äì where a file corresponding to the id might be available</li>
<li>file ‚Äì local copy if one exists</li>
</ul></li>
</ul>


<h5>Query</h5>

<p>Upon receiving a query for file id, check whether the queried file is stored locally</p>

<ul>
<li>If yes, return it; otherwise</li>
<li>Check TTL to limit the search scope

<ul>
<li>Each query is associated a TTL that is decremented each time the message is forwarded</li>
<li>When TTL=1, the query is forwarded with a probability</li>
<li>TTL can be initiated to a random value within some bounds to obscure distance to originator</li>
</ul></li>
<li>Look for the ‚Äúclosest‚Äù id in the table with an unvisited next_hope node

<ul>
<li>If found one, forward the query to the corresponding next_hop</li>
<li>Otherwise, backtrack

<ul>
<li>Ends up performing a Depth First Search (DFS)-like traversal</li>
<li>Search direction ordered by closeness to target</li>
</ul></li>
</ul></li>
<li>When file is returned it is cached along the reverse path (any advantage?)</li>
</ul>


<h5>Insert</h5>

<ul>
<li>First attempt a ‚Äúsearch‚Äù for the file to be inserted</li>
<li>If found, report collision</li>
<li>If not found, insert the file by sending it along the query path</li>
<li>Inserted files are placed on nodes already possessing files with similar keys</li>
<li>A node probabilistically replaces the originator with itself (why?)</li>
</ul>


<h5>Freenet Analysis</h5>

<ul>
<li>Authors claim the following effects:

<ul>
<li>Nodes eventually specialize in locating similar keys

<ul>
<li>If a node is listed in a routing table, it will get queries for related keys</li>
<li>Thus will gain ‚Äúexperience‚Äù answering those queries</li>
</ul></li>
<li>Popular data will be transparently replicated and will exist closer to requestors</li>
<li>As nodes process queries, connectivity increases

<ul>
<li>Nodes will discover other nodes in the network</li>
</ul></li>
</ul></li>

<li>Caveat: lexigraphic closeness of file names/keys may not imply content similarity</li>
</ul>


<h5>Experiment</h5>

<p>High percentage of highly connected nodes provide shortcuts/bridges</p>

<ul>
<li>Make the world a ‚Äúsmall world‚Äù</li>
<li>Most queries only traverse a small number of hops to find the file</li>
</ul>


<h5>Distributed Search</h5>

<ul>
<li>In other words, if double distance, increase number of neighbors by a constant</li>
</ul>


<h5>Properties</h5>

<ul>
<li>Query using intelligent routing

<ul>
<li>Decentralized architecture -&gt; robust</li>
<li>Avoid flooding -&gt; low overhead</li>
<li>DFS search guided by closeness to target</li>
</ul></li>
<li>Integration of query and caching makes it

<ul>
<li>Adaptive to usage patterns: reorganize network reference structure</li>
<li>Free speech: attempts to discover/supplant existing files will just spread the files !</li>
</ul></li>
<li>Provide publisher anonymity, security

<ul>
<li>Each node probabilistically replaces originator with itself</li>
</ul></li>
</ul>


<h5>Issues</h5>

<ul>
<li>Does not always guarantee that a file is found, even if the file is in the network</li>
<li>Good average-case performance, but a potentially long search path in a large network

<ul>
<li>‚ùç  Approaching small-world...</li>
</ul></li>
</ul>







<h4><a name="sec52" id="sec52"></a>Unstructed P2P Summary</h4>

<p class="first">All of the previous P2P systems are called unstructured P2P systems</p>

<h5>Advantages of unstructured P2P</h5>

<ul>
<li>Algorithms tend to be simple</li>
<li>Can optimize for properties such as locality</li>
</ul>


<h5>Disadvantages</h5>

<ul>
<li>Hard to make performance guarantee</li>
<li>Failure even when files exist</li>
</ul>



<h4><a name="sec53" id="sec53"></a>Distributed Hash Tables(DHT)</h4>

<h5>Motivation</h5>

<ul>
<li>Frustrated by popularity of all these ‚Äúhalf-baked‚Äù P2P apps. We can do better! (so they said)</li>
<li>Guaranteed lookup success for data in system</li>
<li>Provable bounds on search time</li>
<li>Provable scalability to millions of node</li>
</ul>


<h5>Abstraction</h5>

<p>a distributed hash-table (DHT) data structure</p>

<ul>
<li>put(key, value) and get(key) ‚Üí value</li>
<li>DHT imposes no structure/meaning on keys</li>
<li>One can build complex data structures using DHT</li>
</ul>


<h5>Implementation</h5>

<ul>
<li>Nodes in system form an interconnection network: ring, zone, tree, hypercube, butterfly network, ...</li>
</ul>



<h4><a name="sec54" id="sec54"></a>Chord</h4>

<ul>
<li>Provides lookup service:

<ul>
<li>Lookup(key) ‚Üí IP address</li>
<li>Chord does not store the data; after lookup, a node queries the IP address to store or retrieve data</li>
</ul></li>
<li>m bit identifier space for both keys and nodes

<ul>
<li>Key identifier = SHA-1(key), where SHA-1() is a popular hash function

<ul>
<li>Key=‚ÄúMatrix3‚Äù ‚Üí ID=60</li>
</ul></li>
<li>Node identifier = SHA-1(IP address)

<ul>
<li>IP=‚Äú198.10.10.1‚Äù ‚Üí ID=123</li>
</ul></li>
</ul></li>
</ul>

<h5>Storage using a Ring</h5>

<p>A key is stored at its successor: node with next higher ID.</p>


<h5>How to Search: One Extreme</h5>

<ul>
<li>Every node knows of every other node</li>
<li>Routing tables are large O(N)</li>
<li>Lookups are fast O(1)</li>
</ul>


<h5>How to Search: the Other Extreme</h5>

<ul>
<li>Every node knows its successor in the ring</li>
<li>Requires O(N) lookups</li>
</ul>


<h5>Chord Solution: ‚Äúfinger tables‚Äù</h5>

<p>Node K knows the node that is maintaining <!-- $ K +  2^i $--><img src="./latex/latex2png-computer_network_applications__305825782.png" alt="latex2png equation" class="latex-inline" />, where K is mapped id of current node</p>

<ul>
<li>Increase distance exponentially (small world?)</li>
</ul>


<h5>Joining the Ring</h5>

<ul>
<li>Use a contact node to obtain info</li>
<li>Transfer keys from successor node to new node</li>
<li>Updating fingers of existing nodes</li>
</ul>


<h5>DHT:Chord Routing</h5>

<ul>
<li>Upon receiving a query for item id, a node checks whether stores the item
locally</li>
<li>If not, forwards the query to the largest node in its successor table that does not exceed id</li>
</ul>




<h4><a name="sec55" id="sec55"></a>Content Addressable Network(CAN)</h4>

<p class="first">Key space is an (virtual) d-dimensional Cartesian space</p>

<ul>
<li>Associate to each item a unique coordinate in the space</li>
<li>Partition the space amongst all of the nodes</li>
</ul>

<h5>Routing</h5>

<ul>
<li>A node maintains state only for its immediate neighboring nodes</li>
<li>Forward to neighbor which is closest to the target point

<ul>
<li>a type of greedy, local routing scheme</li>
</ul></li>
</ul>


<h5>Example: Two Dimensional Space</h5>

<ul>
<li>Space divided among nodes</li>
<li>Each node covers either a square or a rectangular area of ratios 1:2 or 2:1</li>
</ul>

<h5>node I::insert(K,V)</h5>

<ul>
<li>a = hx(K), b = hy(K)</li>
<li>route(K,V) -&gt; (a,b)</li>
<li>(K, V) is stored at (a, b)</li>
</ul>


<h5>node I::retrieve(K)</h5>

<ul>
<li>a = hx(K), b = hy(K)</li>
<li>route ‚Äúretrieve(K)‚Äù to (a,b)</li>
</ul>


<h5>Join</h5>

<p>Inserting a new node affects only a single other node and its immediate neighbors</p>

<ul>
<li>Discover some node J already in CAN</li>
<li>pick a random point (p,q) in space</li>
<li>J routes to (p,q), discovers node N</li>
<li>split N's zone in half... new node owns one half</li>
</ul>

<p>CAN Complexity</p>

<ul>
<li>Guaranteed to find an item if in the network</li>
<li>Scalability

<ul>
<li>For a uniform (regularly) partitioned space with n nodes and d dimensions

<ul>
<li>Per node, number of neighbors is 2d</li>
<li>Routing path length is dn1/d</li>
<li>Average routing path is (dn1/d)/3 hops (due to Manhattan distance routing, expected hops in each dimension is dimension length * 1/3)</li>
</ul></li>
<li>A fixed d can scale the network without increasing per-node state</li>
</ul></li>
<li>Load balancing

<ul>
<li>Hashing achieves some load balancing</li>
<li>Overloaded node replicates popular entries at neighbors</li>
</ul></li>
<li>Robustness

<ul>
<li>No single point of failure</li>
<li>Can route around trouble</li>
</ul></li>
</ul>




<h4><a name="sec56" id="sec56"></a>Chord/CAN Summary</h4>

<ul>
<li>Each node owns some portion of the key-space

<ul>
<li>In CAN, it is a multi-dimensional ‚Äúzone‚Äù</li>
<li>In Chord, it is the key-id-space between two nodes in 1-D ring</li>
</ul></li>
<li>Files and nodes are assigned random locations in key-space

<ul>
<li>Provides some load balancing</li>
<li>Probabilistically equal division of keys to nodes</li>
</ul></li>
<li>Routing/search is local (distributed) and greedy

<ul>
<li>Node X does not know of a path to a key Z</li>
<li>But if node Y appears to be closest to Z among all of the nodes known to X</li>
<li>So route to Y</li>
</ul></li>
</ul>


<h4><a name="sec57" id="sec57"></a>Tapestry (Zhao et al)</h4>

<ul>
<li>Keys interpreted as a sequence of digits</li>
<li>Incremental suffix routing

<ul>
<li>Source to target route is accomplished by correcting one digit at a time</li>
<li>For instance: (to route from 0312 ‚Üí 1643)</li>
<li>0312 ‚Üí 2173 ‚Üí 3243 ‚Üí 2643 ‚Üí 1643</li>
</ul></li>
<li>Each node has a routing table</li>
</ul>


<h4><a name="sec58" id="sec58"></a>Skip List</h4>

<ul>
<li>Each node linked at higher level with probability 1/2.</li>
<li>Time for search: O(log n) on average.</li>
<li>On average, constant number of pointers per node.</li>
<li>Link at level i to nodes with matching prefix of length i. Think of a tree of skip lists that share lower layers.</li>
</ul>




<h4><a name="sec59" id="sec59"></a>Summary: DHT</h4>

<ul>
<li>Underlying metric space.</li>
<li>Nodes embedded in metric space</li>
<li>Location determined by key</li>
<li>Hashing to balance load</li>
<li>Greedy routing</li>
<li>Typically

<ul>
<li>O(logn) space at each node</li>
<li>O(log n) routing time</li>
</ul></li>
</ul>


<h4><a name="sec60" id="sec60"></a>Summary: the lookup problem</h4>

<ul>
<li>Napster (central query server; distributed data server)</li>
<li>Gnutella (decentralized, flooding)</li>
<li>Freenet (search by routing)</li>
<li>Chord (search by routing on a virtual ring)</li>
<li>Content Addressable Network (virtual zones)</li>
</ul>


<h4><a name="sec61" id="sec61"></a>BitTorrent</h4>

<h5>Metadata File Structure</h5>

<ul>
<li>Announce URL of tracker</li>
<li>File name</li>
<li>File length</li>
<li>Piece length (typically 256KB)</li>
<li>SHA-1 hashes of pieces for verification</li>
<li>Also creation date, comment, creator, ...</li>
</ul>


<h5>Tracker Protocol</h5>

<ul>
<li>Communicates with clients via HTTP/HTTPS</li>
<li>Client GET request

<ul>
<li>Info_hash: uniquely identifies the file</li>
<li>Peer_id: chosen by and uniquely identifies the client</li>
<li>Client IP and port</li>
<li>Numwant: how many peers to return (defaults to 50)</li>
<li>Stats: bytes uploaded, downloaded, left</li>
</ul></li>
<li>Tracker response

<ul>
<li>Interval: how often to contact the tracker</li>
<li>List of peers, containing peer id, IP and port</li>
<li>Stats: complete, incomplete</li>
</ul></li>
<li>Tracker-less mode; based on the Kademlia DHT</li>
</ul>


<h5>Piece Selection: Requests/Interests</h5>

<ul>
<li>When downloading starts: choose at random and request them from the peers

<ul>
<li>Get pieces as quickly as possible</li>
<li>Obtain something to offer to others</li>
</ul></li>
<li>After 4 pieces: request (local) rarest first

<ul>
<li>Achieves the fastest replication of rare pieces</li>
<li>Obtain something of value</li>
</ul></li>
<li>Endgame mode</li>
<li>Defense against the ‚Äúlast-block problem‚Äù: cannot finish because missing a few last pieces</li>
<li>Send requests for missing sub-pieces to all peers in our peer list</li>
<li>Send cancel messages upon receipt of a sub-piece</li>
</ul>


<h5>Peer Selection ‚Äì Response/Unchoking</h5>

<ul>
<li>Periodically (typically every 10 seconds) calculate data-receiving rates from all peers</li>
<li>Upload to (unchoke) the fastest

<ul>
<li>constant number (4) of unchoking slots</li>
</ul></li>
</ul>


<h5>Optimistic Unchoking</h5>

<ul>
<li>Periodically select a peer at random and upload to it

<ul>
<li>Typically every 3 unchoking rounds (30 seconds)</li>
</ul></li>
<li>Multi-purpose mechanism

<ul>
<li>Allow bootstrapping of new clients</li>
<li>Continuously look for the fastest peers (exploitation vs exploration)</li>
</ul></li>
</ul>


<h5>Summary</h5>

<ul>
<li>Very widely used

<ul>
<li>Mainline: written in Python</li>
<li>Azureus: the most popular, written in Java</li>
<li>Other popular clients: ABC, BitComet, BitLord, BitTornado, ŒºTorrent, Opera browser</li>
</ul></li>
<li>Many explorations, e.g.

<ul>
<li>BitThief</li>
<li>BitTyrant</li>
</ul></li>
<li>Better understanding
is needed</li>
</ul>





<!-- Emacs Muse Footer -->

<div id="footer" align="center">
	<hr>
    Last Updated: December 25, 2011  
<span>  &nbsp &nbsp;    </span>       
   <img border="0" src="http://cc.amazingcounters.com/counter.php?i=3007311&c=9022246" alt="Hit Counter">
	<span>  &nbsp &nbsp;    </span>    
  <script language="javascript" type="text/javascript" src="http://js.users.51.la/5290848.js"></script>
<noscript><a href="http://www.51.la/?5290848" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/5290848.asp" style="border:none" /></a></noscript>

</div>
	<script type="text/javascript">
	     SyntaxHighlighter.all()
	</script>
</body>
</html>

